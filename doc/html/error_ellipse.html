
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>error_ellipse</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-06-07"><meta name="DC.source" content="error_ellipse.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">error_ellipse.m</a></li><li><a href="#2">Code</a></li></ul></div><h2>error_ellipse.m<a name="1"></a></h2><p>ERROR_ELLIPSE - plot an error ellipse, or ellipsoid, defining confidence region    ERROR_ELLIPSE(C22) - Given a 2x2 covariance matrix, plot the    associated error ellipse, at the origin. It returns a graphics handle    of the ellipse that was drawn.</p><pre>  ERROR_ELLIPSE(C33) - Given a 3x3 covariance matrix, plot the
  associated error ellipsoid, at the origin, as well as its projections
  onto the three axes. Returns a vector of 4 graphics handles, for the
  three ellipses (in the X-Y, Y-Z, and Z-X planes, respectively) and for
  the ellipsoid.</pre><pre>  ERROR_ELLIPSE(C,MU) - Plot the ellipse, or ellipsoid, centered at MU,
  a vector whose length should match that of C (which is 2x2 or 3x3).</pre><pre>  ERROR_ELLIPSE(...,'Property1',Value1,'Name2',Value2,...) sets the
  values of specified properties, including:
    'C' - Alternate method of specifying the covariance matrix
    'mu' - Alternate method of specifying the ellipse (-oid) center
    'conf' - A value betwen 0 and 1 specifying the confidence interval.
      the default is 0.5 which is the 50% error ellipse.
    'scale' - Allow the plot the be scaled to difference units.
    'style' - A plotting style used to format ellipses.
    'clip' - specifies a clipping radius. Portions of the ellipse, -oid,
      outside the radius will not be shown.</pre><pre>  NOTES: C must be positive definite for this function to work properly.</pre><p>by AJ Johnson <a href="http://www.mathworks.de/matlabcentral/fileexchange/4705">http://www.mathworks.de/matlabcentral/fileexchange/4705</a></p><pre class="codeinput"><span class="keyword">function</span> h=error_ellipse(varargin)
</pre><h2>Code<a name="2"></a></h2><pre class="codeinput">default_properties = struct(<span class="keyword">...</span>
  <span class="string">'C'</span>, [], <span class="keyword">...</span><span class="comment"> % The covaraince matrix (required)</span>
  <span class="string">'mu'</span>, [], <span class="keyword">...</span><span class="comment"> % Center of ellipse (optional)</span>
  <span class="string">'conf'</span>, 0.95, <span class="keyword">...</span><span class="comment"> % Percent confidence/100</span>
  <span class="string">'scale'</span>, 1, <span class="keyword">...</span><span class="comment"> % Scale factor, e.g. 1e-3 to plot m as km</span>
  <span class="string">'style'</span>, <span class="string">''</span>, <span class="keyword">...</span><span class="comment">  % Plot style</span>
  <span class="string">'clip'</span>, inf); <span class="comment">% Clipping radius</span>

<span class="keyword">if</span> length(varargin) &gt;= 1 &amp; isnumeric(varargin{1})
  default_properties.C = varargin{1};
  varargin(1) = [];
<span class="keyword">end</span>

<span class="keyword">if</span> length(varargin) &gt;= 1 &amp; isnumeric(varargin{1})
  default_properties.mu = varargin{1};
  varargin(1) = [];
<span class="keyword">end</span>

<span class="keyword">if</span> length(varargin) &gt;= 1 &amp; isnumeric(varargin{1})
  default_properties.conf = varargin{1};
  varargin(1) = [];
<span class="keyword">end</span>

<span class="keyword">if</span> length(varargin) &gt;= 1 &amp; isnumeric(varargin{1})
  default_properties.scale = varargin{1};
  varargin(1) = [];
<span class="keyword">end</span>

<span class="keyword">if</span> length(varargin) &gt;= 1 &amp; ~ischar(varargin{1})
  error(<span class="string">'Invalid parameter/value pair arguments.'</span>)
<span class="keyword">end</span>

prop = getopt(default_properties, varargin{:});
C = prop.C;

<span class="keyword">if</span> isempty(prop.mu)
  mu = zeros(length(C),1);
<span class="keyword">else</span>
  mu = prop.mu;
<span class="keyword">end</span>

conf = prop.conf;
scale = prop.scale;
style = prop.style;

<span class="keyword">if</span> conf &lt;= 0 | conf &gt;= 1
  error(<span class="string">'conf parameter must be in range 0 to 1, exclusive'</span>)
<span class="keyword">end</span>

[r,c] = size(C);
<span class="keyword">if</span> r ~= c | (r ~= 2 &amp; r ~= 3)
  error([<span class="string">'Don''t know what to do with '</span>,num2str(r),<span class="string">'x'</span>,num2str(c),<span class="string">' matrix'</span>])
<span class="keyword">end</span>

x0=mu(1);
y0=mu(2);

<span class="comment">% Compute quantile for the desired percentile</span>
k = sqrt(qchisq(conf,r)); <span class="comment">% r is the number of dimensions (degrees of freedom)</span>

hold_state = get(gca,<span class="string">'nextplot'</span>);

<span class="keyword">if</span> r==3 &amp; c==3
  z0=mu(3);

  <span class="comment">% Make the matrix has positive eigenvalues - else it's not a valid covariance matrix!</span>
  <span class="keyword">if</span> any(eig(C) &lt;=0)
    error(<span class="string">'The covariance matrix must be positive definite (it has non-positive eigenvalues)'</span>)
  <span class="keyword">end</span>

  <span class="comment">% C is 3x3; extract the 2x2 matricies, and plot the associated error</span>
  <span class="comment">% ellipses. They are drawn in space, around the ellipsoid; it may be</span>
  <span class="comment">% preferable to draw them on the axes.</span>
  Cxy = C(1:2,1:2);
  Cyz = C(2:3,2:3);
  Czx = C([3 1],[3 1]);

  [x,y,z] = getpoints(Cxy,prop.clip);
  h1=plot3(x0+k*x,y0+k*y,z0+k*z,prop.style,<span class="string">'linewidth'</span>,2);hold <span class="string">on</span>
  [y,z,x] = getpoints(Cyz,prop.clip);
  h2=plot3(x0+k*x,y0+k*y,z0+k*z,prop.style,<span class="string">'linewidth'</span>,2);hold <span class="string">on</span>
  [z,x,y] = getpoints(Czx,prop.clip);
  h3=plot3(x0+k*x,y0+k*y,z0+k*z,prop.style,<span class="string">'linewidth'</span>,2);hold <span class="string">on</span>


  [eigvec,eigval] = eig(C);

  [X,Y,Z] = ellipsoid(0,0,0,1,1,1);
  XYZ = [X(:),Y(:),Z(:)]*sqrt(eigval)*eigvec';

  X(:) = scale*(k*XYZ(:,1)+x0);
  Y(:) = scale*(k*XYZ(:,2)+y0);
  Z(:) = scale*(k*XYZ(:,3)+z0);
  h4=surf(X,Y,Z);
  colormap <span class="string">gray</span>
  alpha(0.3)
  camlight
  <span class="keyword">if</span> nargout
    h=[h1 h2 h3 h4];
  <span class="keyword">end</span>
<span class="keyword">elseif</span> r==2 &amp; c==2
  <span class="comment">% Make the matrix has positive eigenvalues - else it's not a valid covariance matrix!</span>
  <span class="keyword">if</span> any(eig(C) &lt;=0)
    error(<span class="string">'The covariance matrix must be positive definite (it has non-positive eigenvalues)'</span>)
  <span class="keyword">end</span>

  [x,y,z] = getpoints(C,prop.clip);
  h1=plot(scale*(x0+k*x),scale*(y0+k*y),prop.style,<span class="string">'linewidth'</span>,2);
  set(h1,<span class="string">'zdata'</span>,z+1)
  <span class="keyword">if</span> nargout
    h=h1;
  <span class="keyword">end</span>
<span class="keyword">else</span>
  error(<span class="string">'C (covaraince matrix) must be specified as a 2x2 or 3x3 matrix)'</span>)
<span class="keyword">end</span>
<span class="comment">%axis equal</span>

set(gca,<span class="string">'nextplot'</span>,hold_state);

<span class="comment">%---------------------------------------------------------------</span>
<span class="comment">% getpoints - Generate x and y points that define an ellipse, given a 2x2</span>
<span class="comment">%   covariance matrix, C. z, if requested, is all zeros with same shape as</span>
<span class="comment">%   x and y.</span>
</pre><pre class="codeinput"><span class="keyword">function</span> [x,y,z] = getpoints(C,clipping_radius)

n=100; <span class="comment">% Number of points around ellipse</span>
p=0:pi/n:2*pi; <span class="comment">% angles around a circle</span>

[eigvec,eigval] = eig(C); <span class="comment">% Compute eigen-stuff</span>
xy = [cos(p'),sin(p')] * sqrt(eigval) * eigvec'; <span class="comment">% Transformation</span>
x = xy(:,1);
y = xy(:,2);
z = zeros(size(x));

<span class="comment">% Clip data to a bounding radius</span>
<span class="keyword">if</span> nargin &gt;= 2
  r = sqrt(sum(xy.^2,2)); <span class="comment">% Euclidian distance (distance from center)</span>
  x(r &gt; clipping_radius) = nan;
  y(r &gt; clipping_radius) = nan;
  z(r &gt; clipping_radius) = nan;
<span class="keyword">end</span>

<span class="comment">%---------------------------------------------------------------</span>
<span class="keyword">function</span> x=qchisq(P,n)
<span class="comment">% QCHISQ(P,N) - quantile of the chi-square distribution.</span>
<span class="keyword">if</span> nargin&lt;2
  n=1;
<span class="keyword">end</span>

s0 = P==0;
s1 = P==1;
s = P&gt;0 &amp; P&lt;1;
x = 0.5*ones(size(P));
x(s0) = -inf;
x(s1) = inf;
x(~(s0|s1|s))=nan;

<span class="keyword">for</span> ii=1:14
  dx = -(pchisq(x(s),n)-P(s))./dchisq(x(s),n);
  x(s) = x(s)+dx;
  <span class="keyword">if</span> all(abs(dx) &lt; 1e-6)
    <span class="keyword">break</span>;
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%---------------------------------------------------------------</span>
<span class="keyword">function</span> F=pchisq(x,n)
<span class="comment">% PCHISQ(X,N) - Probability function of the chi-square distribution.</span>
<span class="keyword">if</span> nargin&lt;2
  n=1;
<span class="keyword">end</span>
F=zeros(size(x));

<span class="keyword">if</span> rem(n,2) == 0
  s = x&gt;0;
  k = 0;
  <span class="keyword">for</span> jj = 0:n/2-1;
    k = k + (x(s)/2).^jj/factorial(jj);
  <span class="keyword">end</span>
  F(s) = 1-exp(-x(s)/2).*k;
<span class="keyword">else</span>
  <span class="keyword">for</span> ii=1:numel(x)
    <span class="keyword">if</span> x(ii) &gt; 0
      F(ii) = quadl(@dchisq,0,x(ii),1e-6,0,n);
    <span class="keyword">else</span>
      F(ii) = 0;
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%---------------------------------------------------------------</span>
<span class="keyword">function</span> f=dchisq(x,n)
<span class="comment">% DCHISQ(X,N) - Density function of the chi-square distribution.</span>
<span class="keyword">if</span> nargin&lt;2
  n=1;
<span class="keyword">end</span>
f=zeros(size(x));
s = x&gt;=0;
f(s) = x(s).^(n/2-1).*exp(-x(s)/2)./(2^(n/2)*gamma(n/2));

<span class="comment">%---------------------------------------------------------------</span>
<span class="keyword">function</span> properties = getopt(properties,varargin)
<span class="comment">%GETOPT - Process paired optional arguments as 'prop1',val1,'prop2',val2,...</span>
<span class="comment">%</span>
<span class="comment">%   getopt(properties,varargin) returns a modified properties structure,</span>
<span class="comment">%   given an initial properties structure, and a list of paired arguments.</span>
<span class="comment">%   Each argumnet pair should be of the form property_name,val where</span>
<span class="comment">%   property_name is the name of one of the field in properties, and val is</span>
<span class="comment">%   the value to be assigned to that structure field.</span>
<span class="comment">%</span>
<span class="comment">%   No validation of the values is performed.</span>
<span class="comment">%</span>
<span class="comment">% EXAMPLE:</span>
<span class="comment">%   properties = struct('zoom',1.0,'aspect',1.0,'gamma',1.0,'file',[],'bg',[]);</span>
<span class="comment">%   properties = getopt(properties,'aspect',0.76,'file','mydata.dat')</span>
<span class="comment">% would return:</span>
<span class="comment">%   properties =</span>
<span class="comment">%         zoom: 1</span>
<span class="comment">%       aspect: 0.7600</span>
<span class="comment">%        gamma: 1</span>
<span class="comment">%         file: 'mydata.dat'</span>
<span class="comment">%           bg: []</span>
<span class="comment">%</span>
<span class="comment">% Typical usage in a function:</span>
<span class="comment">%   properties = getopt(properties,varargin{:})</span>


<span class="comment">% Process the properties (optional input arguments)</span>
prop_names = fieldnames(properties);
TargetField = [];
<span class="keyword">for</span> ii=1:length(varargin)
  arg = varargin{ii};
  <span class="keyword">if</span> isempty(TargetField)
    <span class="keyword">if</span> ~ischar(arg)
      error(<span class="string">'Propery names must be character strings'</span>);
    <span class="keyword">end</span>
    f = find(strcmp(prop_names, arg));
    <span class="keyword">if</span> length(f) == 0
      error(<span class="string">'%s '</span>,[<span class="string">'invalid property '''</span>,arg,<span class="string">'''; must be one of:'</span>],prop_names{:});
    <span class="keyword">end</span>
    TargetField = arg;
  <span class="keyword">else</span>
    <span class="comment">% properties.(TargetField) = arg; % Ver 6.5 and later only</span>
    properties = setfield(properties, TargetField, arg); <span class="comment">% Ver 6.1 friendly</span>
    TargetField = <span class="string">''</span>;
  <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(TargetField)
  error(<span class="string">'Property names and values must be specified in pairs.'</span>);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% error_ellipse.m
% ERROR_ELLIPSE - plot an error ellipse, or ellipsoid, defining confidence region
%    ERROR_ELLIPSE(C22) - Given a 2x2 covariance matrix, plot the
%    associated error ellipse, at the origin. It returns a graphics handle
%    of the ellipse that was drawn.
%
%    ERROR_ELLIPSE(C33) - Given a 3x3 covariance matrix, plot the
%    associated error ellipsoid, at the origin, as well as its projections
%    onto the three axes. Returns a vector of 4 graphics handles, for the
%    three ellipses (in the X-Y, Y-Z, and Z-X planes, respectively) and for
%    the ellipsoid.
%
%    ERROR_ELLIPSE(C,MU) - Plot the ellipse, or ellipsoid, centered at MU,
%    a vector whose length should match that of C (which is 2x2 or 3x3).
%
%    ERROR_ELLIPSE(...,'Property1',Value1,'Name2',Value2,...) sets the
%    values of specified properties, including:
%      'C' - Alternate method of specifying the covariance matrix
%      'mu' - Alternate method of specifying the ellipse (-oid) center
%      'conf' - A value betwen 0 and 1 specifying the confidence interval.
%        the default is 0.5 which is the 50% error ellipse.
%      'scale' - Allow the plot the be scaled to difference units.
%      'style' - A plotting style used to format ellipses.
%      'clip' - specifies a clipping radius. Portions of the ellipse, -oid,
%        outside the radius will not be shown.
%
%    NOTES: C must be positive definite for this function to work properly.
%
%
% by AJ Johnson
% http://www.mathworks.de/matlabcentral/fileexchange/4705

function h=error_ellipse(varargin)
%% Code
default_properties = struct(...
  'C', [], ... % The covaraince matrix (required)
  'mu', [], ... % Center of ellipse (optional)
  'conf', 0.95, ... % Percent confidence/100
  'scale', 1, ... % Scale factor, e.g. 1e-3 to plot m as km
  'style', '', ...  % Plot style
  'clip', inf); % Clipping radius

if length(varargin) >= 1 & isnumeric(varargin{1})
  default_properties.C = varargin{1};
  varargin(1) = [];
end

if length(varargin) >= 1 & isnumeric(varargin{1})
  default_properties.mu = varargin{1};
  varargin(1) = [];
end

if length(varargin) >= 1 & isnumeric(varargin{1})
  default_properties.conf = varargin{1};
  varargin(1) = [];
end

if length(varargin) >= 1 & isnumeric(varargin{1})
  default_properties.scale = varargin{1};
  varargin(1) = [];
end

if length(varargin) >= 1 & ~ischar(varargin{1})
  error('Invalid parameter/value pair arguments.') 
end

prop = getopt(default_properties, varargin{:});
C = prop.C;

if isempty(prop.mu)
  mu = zeros(length(C),1);
else
  mu = prop.mu;
end

conf = prop.conf;
scale = prop.scale;
style = prop.style;

if conf <= 0 | conf >= 1
  error('conf parameter must be in range 0 to 1, exclusive')
end

[r,c] = size(C);
if r ~= c | (r ~= 2 & r ~= 3)
  error(['Don''t know what to do with ',num2str(r),'x',num2str(c),' matrix'])
end

x0=mu(1);
y0=mu(2);

% Compute quantile for the desired percentile
k = sqrt(qchisq(conf,r)); % r is the number of dimensions (degrees of freedom)

hold_state = get(gca,'nextplot');

if r==3 & c==3
  z0=mu(3);
  
  % Make the matrix has positive eigenvalues - else it's not a valid covariance matrix!
  if any(eig(C) <=0)
    error('The covariance matrix must be positive definite (it has non-positive eigenvalues)')
  end

  % C is 3x3; extract the 2x2 matricies, and plot the associated error
  % ellipses. They are drawn in space, around the ellipsoid; it may be
  % preferable to draw them on the axes.
  Cxy = C(1:2,1:2);
  Cyz = C(2:3,2:3);
  Czx = C([3 1],[3 1]);

  [x,y,z] = getpoints(Cxy,prop.clip);
  h1=plot3(x0+k*x,y0+k*y,z0+k*z,prop.style,'linewidth',2);hold on
  [y,z,x] = getpoints(Cyz,prop.clip);
  h2=plot3(x0+k*x,y0+k*y,z0+k*z,prop.style,'linewidth',2);hold on
  [z,x,y] = getpoints(Czx,prop.clip);
  h3=plot3(x0+k*x,y0+k*y,z0+k*z,prop.style,'linewidth',2);hold on

  
  [eigvec,eigval] = eig(C);

  [X,Y,Z] = ellipsoid(0,0,0,1,1,1);
  XYZ = [X(:),Y(:),Z(:)]*sqrt(eigval)*eigvec';
  
  X(:) = scale*(k*XYZ(:,1)+x0);
  Y(:) = scale*(k*XYZ(:,2)+y0);
  Z(:) = scale*(k*XYZ(:,3)+z0);
  h4=surf(X,Y,Z);
  colormap gray
  alpha(0.3)
  camlight
  if nargout
    h=[h1 h2 h3 h4];
  end
elseif r==2 & c==2
  % Make the matrix has positive eigenvalues - else it's not a valid covariance matrix!
  if any(eig(C) <=0)
    error('The covariance matrix must be positive definite (it has non-positive eigenvalues)')
  end

  [x,y,z] = getpoints(C,prop.clip);
  h1=plot(scale*(x0+k*x),scale*(y0+k*y),prop.style,'linewidth',2);
  set(h1,'zdata',z+1)
  if nargout
    h=h1;
  end
else
  error('C (covaraince matrix) must be specified as a 2x2 or 3x3 matrix)')
end
%axis equal

set(gca,'nextplot',hold_state);

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% getpoints - Generate x and y points that define an ellipse, given a 2x2
%   covariance matrix, C. z, if requested, is all zeros with same shape as
%   x and y.
function [x,y,z] = getpoints(C,clipping_radius)

n=100; % Number of points around ellipse
p=0:pi/n:2*pi; % angles around a circle

[eigvec,eigval] = eig(C); % Compute eigen-stuff
xy = [cos(p'),sin(p')] * sqrt(eigval) * eigvec'; % Transformation
x = xy(:,1);
y = xy(:,2);
z = zeros(size(x));

% Clip data to a bounding radius
if nargin >= 2
  r = sqrt(sum(xy.^2,2)); % Euclidian distance (distance from center)
  x(r > clipping_radius) = nan;
  y(r > clipping_radius) = nan;
  z(r > clipping_radius) = nan;
end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
function x=qchisq(P,n)
% QCHISQ(P,N) - quantile of the chi-square distribution.
if nargin<2
  n=1;
end

s0 = P==0;
s1 = P==1;
s = P>0 & P<1;
x = 0.5*ones(size(P));
x(s0) = -inf;
x(s1) = inf;
x(~(s0|s1|s))=nan;

for ii=1:14
  dx = -(pchisq(x(s),n)-P(s))./dchisq(x(s),n);
  x(s) = x(s)+dx;
  if all(abs(dx) < 1e-6)
    break;
  end
end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
function F=pchisq(x,n)
% PCHISQ(X,N) - Probability function of the chi-square distribution.
if nargin<2
  n=1;
end
F=zeros(size(x));

if rem(n,2) == 0
  s = x>0;
  k = 0;
  for jj = 0:n/2-1;
    k = k + (x(s)/2).^jj/factorial(jj);
  end
  F(s) = 1-exp(-x(s)/2).*k;
else
  for ii=1:numel(x)
    if x(ii) > 0
      F(ii) = quadl(@dchisq,0,x(ii),1e-6,0,n);
    else
      F(ii) = 0;
    end
  end
end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
function f=dchisq(x,n)
% DCHISQ(X,N) - Density function of the chi-square distribution.
if nargin<2
  n=1;
end
f=zeros(size(x));
s = x>=0;
f(s) = x(s).^(n/2-1).*exp(-x(s)/2)./(2^(n/2)*gamma(n/2));

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
function properties = getopt(properties,varargin)
%GETOPT - Process paired optional arguments as 'prop1',val1,'prop2',val2,...
%
%   getopt(properties,varargin) returns a modified properties structure,
%   given an initial properties structure, and a list of paired arguments.
%   Each argumnet pair should be of the form property_name,val where
%   property_name is the name of one of the field in properties, and val is
%   the value to be assigned to that structure field.
%
%   No validation of the values is performed.
%
% EXAMPLE:
%   properties = struct('zoom',1.0,'aspect',1.0,'gamma',1.0,'file',[],'bg',[]);
%   properties = getopt(properties,'aspect',0.76,'file','mydata.dat')
% would return:
%   properties = 
%         zoom: 1
%       aspect: 0.7600
%        gamma: 1
%         file: 'mydata.dat'
%           bg: []
%
% Typical usage in a function:
%   properties = getopt(properties,varargin{:})


% Process the properties (optional input arguments)
prop_names = fieldnames(properties);
TargetField = [];
for ii=1:length(varargin)
  arg = varargin{ii};
  if isempty(TargetField)
    if ~ischar(arg)
      error('Propery names must be character strings');
    end
    f = find(strcmp(prop_names, arg));
    if length(f) == 0
      error('%s ',['invalid property ''',arg,'''; must be one of:'],prop_names{:});
    end
    TargetField = arg;
  else
    % properties.(TargetField) = arg; % Ver 6.5 and later only
    properties = setfield(properties, TargetField, arg); % Ver 6.1 friendly
    TargetField = '';
  end
end
if ~isempty(TargetField)
  error('Property names and values must be specified in pairs.');
end

##### SOURCE END #####
--></body></html>